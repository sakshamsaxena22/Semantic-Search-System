LL - OddEven
import java.util.*;

class Main {
    static class LinkedList {
        private class Node {
            int data;
            Node next;

            Node(int data) {
                this.data = data;
                this.next = null;
            }
        }

        private Node head;
        private Node tail;
        private int size;

        public LinkedList() {
            this.head = null;
            this.tail = null;
            this.size = 0;
        }

        public LinkedList(Node head, Node tail, int size) {
            this.head = head;
            this.tail = tail;
            this.size = size;
        }

        public int size() {
            return this.size;
        }

        public boolean isEmpty() {
            return this.size() == 0;
        }

        public void addLast(int data) {
            Node newNode = new Node(data);
            if (isEmpty()) {
                this.head = newNode;
                this.tail = newNode;
            } else {
                this.tail.next = newNode;
                this.tail = newNode;
            }
            this.size++;
        }

        public void segregateOddEven() {
            if (isEmpty() || size() == 1) {
                return; // No need to rearrange if list is empty or has only one node
            }

            Node oddHead = null, oddTail = null;
            Node evenHead = null, evenTail = null;
            Node current = head;

            while (current != null) {
                if (current.data % 2 == 0) { // even
                    if (evenHead == null) {
                        evenHead = current;
                        evenTail = current;
                    } else {
                        evenTail.next = current;
                        evenTail = current;
                    }
                } else { // odd
                    if (oddHead == null) {
                        oddHead = current;
                        oddTail = current;
                    } else {
                        oddTail.next = current;
                        oddTail = current;
                    }
                }
                current = current.next;
            }

            if (oddHead == null) {
                head = evenHead;
            } else {
                head = oddHead;
                oddTail.next = evenHead;
            }

            if (evenTail != null) {
                evenTail.next = null; // to end the list
            }
        }

        public void display() {
            Node current = this.head;
            while (current != null) {
                System.out.print(current.data + " ");
                current = current.next;
            }
            System.out.println();
        }
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int N = scanner.nextInt(); // Number of elements in the list

        LinkedList list = new LinkedList();

        // Reading elements of the list
        for (int i = 0; i < N; i++) {
            int data = scanner.nextInt();
            list.addLast(data);
        }

        list.segregateOddEven(); // Rearranging the list
        list.display(); // Displaying the modified list
    }
}


Kth element from last in linked list

import java.util.Scanner;

class Node {
    int data;
    Node next;

    Node(int data) {
        this.data = data;
        this.next = null;
    }
}

class Main {
    static Node head;

    // Function to find the kth element from the last in a linked list
    static int kthFromLast(int k) {
        Node fast = head;
        Node slow = head;

        // Move the fast pointer k steps ahead
        for (int i = 0; i < k; i++) {
            if (fast == null) {
                System.out.println("Error: k is greater than the length of the linked list.");
                return -1;
            }
            fast = fast.next;
        }

        // Move both pointers until the fast pointer reaches the end of the list
        while (fast != null) {
            fast = fast.next;
            slow = slow.next;
        }

        // Return the data of the node pointed to by the slow pointer
        return slow.data;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Read the linked list values
        String[] values = scanner.nextLine().split(" ");
        head = new Node(Integer.parseInt(values[0]));
        Node current = head;
        for (int i = 1; i < values.length - 1; i++) {
            current.next = new Node(Integer.parseInt(values[i]));
            current = current.next;
        }

        // Read the value of k
        int k = scanner.nextInt();

        // Find the kth element from the last
        int kthElement = kthFromLast(k);

        // Output the result
        System.out.println(kthElement);
    }
}



Sum of two Linked Lists


import java.util.*;

class Node {
    int data;
    Node next;

    Node(int d) {
        data = d;
        next = null;
    }
}

public class Main {
    static List<Integer> ans = new ArrayList<>();

    static void insertAtHead(Node head, int d) {
        Node newNode = new Node(d);
        newNode.next = head.next;
        head.next = newNode;
    }

    static void printReverse(Node head) {
        while (head != null) {
            ans.add(head.data);
            head = head.next;
        }
        Collections.reverse(ans);
        for (int x : ans) {
            System.out.print(x + " ");
        }
        System.out.println();
    }

    static Node addListsRecursive(Node node1, Node node2, int carry) {
        if (node1 == null && node2 == null) {
            if (carry > 0) {
                return new Node(carry);
            }
            return null;
        }

        int value1 = (node1 != null) ? node1.data : 0;
        int value2 = (node2 != null) ? node2.data : 0;

        int sum = (value1 + value2 + carry) % 10;
        carry = (value1 + value2 + carry) / 10;

        Node currentHead = new Node(sum);

        Node node1Next = (node1 != null) ? node1.next : null;
        Node node2Next = (node2 != null) ? node2.next : null;

        currentHead.next = addListsRecursive(node1Next, node2Next, carry);

        return currentHead;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        Node head1 = new Node(0);
        Node head2 = new Node(0);

        int n = scanner.nextInt();
        int m = scanner.nextInt();

        for (int i = 0; i < n; i++) {
            insertAtHead(head1, scanner.nextInt());
        }

        for (int i = 0; i < m; i++) {
            insertAtHead(head2, scanner.nextInt());
        }

        int carry = 0;
        Node newHead = addListsRecursive(head1.next, head2.next, carry);
        printReverse(newHead);
    }
}




Triplet from three linked lists




import java.util.Scanner;

class Node {
    int data;
    Node next;

    Node(int data) {
        this.data = data;
        this.next = null;
    }
}

class LinkedList {
    Node head;

    void addLast(int data) {
        Node newNode = new Node(data);
        if (head == null) {
            head = newNode;
        } else {
            Node temp = head;
            while (temp.next != null) {
                temp = temp.next;
            }
            temp.next = newNode;
        }
    }
}

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Read the sizes of the three linked lists
        int n = scanner.nextInt();
        int m = scanner.nextInt();
        int k = scanner.nextInt();

        // Create three linked lists
        LinkedList list1 = new LinkedList();
        LinkedList list2 = new LinkedList();
        LinkedList list3 = new LinkedList();

        // Read the elements of the first linked list
        for (int i = 0; i < n; i++) {
            int data = scanner.nextInt();
            list1.addLast(data);
        }

        // Read the elements of the second linked list
        for (int i = 0; i < m; i++) {
            int data = scanner.nextInt();
            list2.addLast(data);
        }

        // Read the elements of the third linked list
        for (int i = 0; i < k; i++) {
            int data = scanner.nextInt();
            list3.addLast(data);
        }

        // Read the target value
        int target = scanner.nextInt();

        // Iterate through all possible combinations of nodes from the three linked lists
        Node current1 = list1.head;
        while (current1 != null) {
            Node current2 = list2.head;
            while (current2 != null) {
                Node current3 = list3.head;
                while (current3 != null) {
                    // Calculate the sum of the values of the nodes in the current combination
                    int sum = current1.data + current2.data + current3.data;
                    // If the sum equals the target, print the combination and return
                    if (sum == target) {
                        System.out.println(current1.data + " " + current2.data + " " + current3.data);
                        return;
                    }
                    current3 = current3.next;
                }
                current2 = current2.next;
            }
            current1 = current1.next;
        }

    }
}





Delete Nodes - LL



#include<iostream>
using namespace std;

class node{
	public:
	int data;
	node*next;

	node(int d) {
		data=d;
		next=NULL;
	}
};

void print(node*head) {
	while(head!=NULL) {
		cout<<head->data<<" ";
		head=head->next;
	}
}

void insertAtTail(node*&head,int d) {
	if(head==NULL) {
		head=new node(d);
		return;
	}
	node*n=new node(d);
	node*tail=head;
	while(tail->next!=NULL) {
		tail=tail->next;
	}
	tail->next=n;
}

node* takeInput(node*head,int n) {
	head=NULL;
	while(n) {
		int d;
		cin>>d;
		insertAtTail(head,d);
		n--;
	}

	return head;
}

void deleteNode(node*&head,node*del) {
	if(del==head) {
		head=head->next;
		delete del;
		return;
	}
	node*temp=head;	
	while(temp->next!=del) {
		temp=temp->next;
	}
	if(del->next)
        temp->next=del->next;
    else
        // temp->next = del;
        temp->next = NULL;
        // because del is going to delete 
	delete del;
}

void deleteRight(node*&head) {
	node*first=head;
	while(first && first->next!=NULL) {
		node*second=first->next;
        node*temp= first->next;
		while(second!=NULL) {
			if(first->data < second->data) {
				deleteNode(head,first);
				break;
			}
			else {
				second=second->next;
			}
		}
		// first=first->next;
        // if first is deleted then it will give run errror
        first = temp;
	}
	
	
}

int main() {
	int n;
	cin>>n;
	node*head=takeInput(head,n);
	deleteRight(head);
	print(head);

	return 0;
}





Merge Sorted Linked Lists



import java.util.Scanner;

class Node {
    int data;
    Node next;

    Node(int d) {
        data = d;
        next = null;
    }
}

public class Main {

    // Function to merge two sorted linked lists
    public static Node mergeSortedLists(Node l1, Node l2) {
        Node dummy = new Node(0);
        Node current = dummy;

        // Traverse both lists and compare the nodes
        while (l1 != null && l2 != null) {
            if (l1.data < l2.data) {
                current.next = l1;
                l1 = l1.next;
            } else {
                current.next = l2;
                l2 = l2.next;
            }
            current = current.next;
        }

        // Attach remaining nodes of l1 or l2
        if (l1 != null) {
            current.next = l1;
        } else {
            current.next = l2;
        }

        return dummy.next;
    }

    // Function to print the linked list
    public static void printLinkedList(Node head) {
        Node current = head;
        while (current != null) {
            System.out.print(current.data + " ");
            current = current.next;
        }
        System.out.println();
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        int T = scanner.nextInt(); // Number of test cases

        while (T-- > 0) {
            int N1 = scanner.nextInt(); // Size of list 1
            Node l1 = null;
            Node tail1 = null;
            for (int i = 0; i < N1; i++) {
                int value = scanner.nextInt();
                Node newNode = new Node(value);
                if (l1 == null) {
                    l1 = newNode;
                    tail1 = newNode;
                } else {
                    tail1.next = newNode;
                    tail1 = newNode;
                }
            }

            int N2 = scanner.nextInt(); // Size of list 2
            Node l2 = null;
            Node tail2 = null;
            for (int i = 0; i < N2; i++) {
                int value = scanner.nextInt();
                Node newNode = new Node(value);
                if (l2 == null) {
                    l2 = newNode;
                    tail2 = newNode;
                } else {
                    tail2.next = newNode;
                    tail2 = newNode;
                }
            }

            Node mergedList = mergeSortedLists(l1, l2); // Merge two sorted lists
            printLinkedList(mergedList); // Print the merged list
        }

        scanner.close();
    }
}


Linked List-K Append


import java.util.Scanner;

class Node {
    public int data;
    public Node next;

    Node(int d) {
        data = d;
        next = null;
    }
}

class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Input N - size of the linked list
        int N = scanner.nextInt();

        // Input elements of the linked list
        Node head = null;
        Node tail = null;
        for (int i = 0; i < N; i++) {
            int value = scanner.nextInt();
            Node newNode = new Node(value);
            if (head == null) {
                head = newNode;
                tail = newNode;
            } else {
                tail.next = newNode;
                tail = newNode;
            }
        }

        // Input K - number of elements to be appended
        int K = scanner.nextInt();

        // Append the last K elements to the front of the linked list
        head = appendLastKToFirst(head, N, K);

        // Display the modified linked list
        printLinkedList(head);

        scanner.close();
    }

    // Function to append the last K elements of a linked list to the front
    public static Node appendLastKToFirst(Node head, int N, int K) {
        if (head == null || K == 0) {
            return head;
        }

        // Calculate the effective value of K
        K %= N;

        if (K == 0) {
            return head; // No change if K is multiple of N
        }

        Node fast = head;
        Node slow = head;

        // Move fast pointer K steps ahead
        for (int i = 0; i < K; i++) {
            fast = fast.next;
        }

        // Move both pointers until fast reaches the end
        while (fast.next != null) {
            slow = slow.next;
            fast = fast.next;
        }

        // Break the list at the (N - K)th node
        fast.next = head;
        head = slow.next;
        slow.next = null;

        return head;
    }

    // Function to print the linked list
    public static void printLinkedList(Node head) {
        while (head != null) {
            System.out.print(head.data + " ");
            head = head.next;
        }
    }
}


Cycle Detection and Removal in Linked List

#include <bits/stdc++.h>
using namespace std;

class node
{
public:
    int data;
    node *next;
    node(int d)
    {
        data = d;
        next = NULL;
    }
};

// head - Head pointer of the Linked List
// Return a boolean value indicating the presence of cycle
// If the cycle is present, modify the linked list to remove the cycle as well
bool floydCycleRemoval(node *head)
{
    /* Code here */
	node *slow = head;
	node *fast = head;

	while (fast != NULL && fast->next != NULL){

		fast = fast->next->next;
		slow = slow->next;

		if (fast == slow) {
            fast = head;
			
            while(slow->next != fast->next)
            {
                slow = slow->next;
                fast = fast->next;
            }
            slow->next=NULL;

			return 1;
		}
	}

	return 0;
}

/*
*
*
*   You do not need to refer or modify any code below this. 
*   Only modify the above function definition.
*	Any modications to code below could lead to a 'Wrong Answer' verdict despite above code being correct.
*	You do not even need to read or know about the code below.
*
*
*
*/

void buildCycleList(node *&head)
{
    unordered_map<int, node *> hash;
    int x;
    cin >> x;
    if (x == -1)
    {
        head = NULL;
        return;
    }
    head = new node(x);
    hash[x] = head;
    node *current = head;
    while (x != -1)
    {
        cin >> x;
        if (x == -1)
            break;
        if (hash.find(x) != hash.end())
        {
            current->next = hash[x];
            return;
        }
        node *n = new node(x);
        current->next = n;
        current = n;
        hash[x] = n;
    }
    current->next = NULL;
}

void printLinkedList(node *head)
{
    unordered_set<int> s;
    while (head != NULL)
    {
        if (s.find(head->data) != s.end())
        {
            cout << "\nCycle detected at " << head->data;
            return;
        }
        cout << head->data << " ";
        s.insert(head->data);
        head = head->next;
    }
}

int main()
{
    node *head = NULL;

    buildCycleList(head);

    bool cyclePresent = floydCycleRemoval(head);
    if (cyclePresent)
    {
        cout << "Cycle was present\n";
    }
    else
    {
        cout << "No cycle\n";
    }

    cout << "Linked List - ";
    printLinkedList(head);

    return 0;
}




LL - k Reverse


import java.util.Scanner;

class ListNode {
    int val;
    ListNode next;

    ListNode(int val) {
        this.val = val;
        this.next = null;
    }
}

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        int n = scanner.nextInt(); // Number of elements in the list
        int k = scanner.nextInt(); // Group size

        ListNode head = null; // Head of the linked list
        ListNode tail = null; // Tail of the linked list

        // Construct the linked list
        for (int i = 0; i < n; i++) {
            int val = scanner.nextInt();
            if (head == null) {
                head = new ListNode(val);
                tail = head;
            } else {
                tail.next = new ListNode(val);
                tail = tail.next;
            }
        }

        // Reverse the list taking k elements at a time
        head = reverseKGroup(head, k);

        // Print the updated list
        printList(head);

        scanner.close();
    }

    // Function to reverse a sublist of the linked list starting from the given node
    private static ListNode reverse(ListNode head, int k) {
        ListNode prev = null;
        ListNode current = head;
        ListNode next = null;

        while (k > 0 && current != null) {
            next = current.next;
            current.next = prev;
            prev = current;
            current = next;
            k--;
        }

        return prev; // Return the new head of the reversed sublist
    }

    // Function to reverse the linked list taking k elements at a time
    private static ListNode reverseKGroup(ListNode head, int k) {
        if (head == null || k == 1) {
            return head; // No need to reverse
        }

        ListNode dummy = new ListNode(0); // Dummy node to handle the case where head node changes
        dummy.next = head;
        ListNode current = dummy;
        
        while (current != null) {
            ListNode start = current.next; // Start of the current group
            ListNode end = start; // End of the current group
            
            // Find the end of the current group
            int count = k;
            while (count > 1 && end != null) {
                end = end.next;
                count--;
            }
            
            // If we cannot form a group of size k, break the loop
            if (end == null) {
                break;
            }
            
            ListNode nextGroup = end.next; // Head of the next group
            
            // Reverse the current group
            end.next = null; // Disconnect the current group
            current.next = reverse(start, k); // Reverse the current group and connect it to the previous group
            start.next = nextGroup; // Connect the end of the reversed group to the head of the next group
            
            // Move to the next group
            current = start;
        }
        
        return dummy.next; // Return the head of the updated list
    }

    // Function to print the linked list
    private static void printList(ListNode head) {
        while (head != null) {
            System.out.print(head.val + " ");
            head = head.next;
        }
    }
}



Partition List

import java.util.Scanner;

class ListNode {
    int val;
    ListNode next;

    ListNode(int val) {
        this.val = val;
        this.next = null;
    }
}

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        int N = scanner.nextInt();
        int x = scanner.nextInt();

        ListNode head = null;
        ListNode tail = null;

        for (int i = 0; i < N; i++) {
            int val = scanner.nextInt();
            if (head == null) {
                head = new ListNode(val);
                tail = head;
            } else {
                tail.next = new ListNode(val);
                tail = tail.next;
            }
        }

        head = partition(head, x);
        printList(head);

        scanner.close();
    }

    private static ListNode partition(ListNode head, int x) {
        if (head == null || head.next == null) {
            return head; // No need to partition if there are 0 or 1 nodes
        }

        ListNode dummySmaller = new ListNode(0); // Dummy node for the smaller partition
        ListNode smallerTail = dummySmaller;

        ListNode dummyGreaterEqual = new ListNode(0); // Dummy node for the greater or equal partition
        ListNode greaterEqualTail = dummyGreaterEqual;

        while (head != null) {
            if (head.val < x) {
                smallerTail.next = head;
                smallerTail = smallerTail.next;
            } else {
                greaterEqualTail.next = head;
                greaterEqualTail = greaterEqualTail.next;
            }
            head = head.next;
        }

        // Connect the two partitions
        smallerTail.next = dummyGreaterEqual.next;
        // Make sure to end the list at the greater or equal partition
        greaterEqualTail.next = null;

        return dummySmaller.next;
    }

    private static void printList(ListNode head) {
        while (head != null) {
            System.out.print(head.val + " ");
            head = head.next;
        }
    }
}


Delete From Linked List (Q Queries)


import java.util.Scanner;

class Node {
    int data;
    Node next;

    Node(int data) {
        this.data = data;
        this.next = null;
    }
}

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Read the number of nodes and queries
        int n = scanner.nextInt();
        int q = scanner.nextInt();

        // Build the linked list
        Node head = null;
        Node tail = null;
        for (int i = 0; i < n; i++) {
            int value = scanner.nextInt();
            if (head == null) {
                head = new Node(value);
                tail = head;
            } else {
                tail.next = new Node(value);
                tail = tail.next;
            }
        }

        // Process the queries
        for (int i = 0; i < q; i++) {
            int indexToDelete = scanner.nextInt();
            head = deleteAtIndex(head, indexToDelete);
            printList(head);
        }

        scanner.close();
    }

    // Function to delete a node at a given index
    private static Node deleteAtIndex(Node head, int index) {
        if (head == null || index < 0) {
            return head;
        }

        // If index is 0, delete the head node
        if (index == 0) {
            return head.next;
        }

        // Traverse the list to find the node at the previous index
        Node current = head;
        for (int i = 0; i < index - 1 && current.next != null; i++) {
            current = current.next;
        }

        // If index is out of range, or the next node is null, return head
        if (current == null || current.next == null) {
            return head;
        }

        // Delete the node at the given index
        current.next = current.next.next;

        return head;
    }

    // Function to print the linked list
    private static void printList(Node head) {
        while (head != null) {
            System.out.print(head.data + " ");
            head = head.next;
        }
        System.out.println();
    }
}





Intersection point of two linked lists



import java.util.*;

class Node {
    public int data;
    public Node next;

    Node(int d) {
        data = d;
        next = null;
    }
}

class Solution {
    // This function gets two arguments - the head pointers of the two linked lists
    // Return the node which is the intersection point of these linked lists
    // It is assured that the two lists intersect
    Node intersectionOfTwoLinkedLists(Node l1, Node l2) {
        if (l1 == null || l2 == null)
            return null;

        Node p1 = l1;
        Node p2 = l2;

        // Traverse both lists until they intersect
        while (p1 != p2) {
            p1 = (p1 == null) ? l2 : p1.next;
            p2 = (p2 == null) ? l1 : p2.next;
        }

        return p1; // Return the intersection node
    }
}

public class Main {

    static Scanner sc = new Scanner(System.in);

    public static Node buildList(HashMap<Integer, Node> hash) {
        int x = sc.nextInt();
        Node head = new Node(x);
        Node current = head;
        hash.put(x, head);
        while (x != -1) {
            x = sc.nextInt();
            if (x == -1)
                break;
            Node n = new Node(x);
            hash.put(x, n);
            current.next = n;
            current = n;
        }
        current.next = null;
        return head;
    }

    public static void printLinkedList(Node head) {
        Node temp = head;
        while (temp != null) {
            System.out.print(temp.data + " ");
            temp = temp.next;
        }
        System.out.println();
    }

    public static void main(String[] args) {

        HashMap<Integer, Node> hash = new HashMap<Integer, Node>();
        Node l1 = buildList(hash);

        Node l2 = null;
        int x = sc.nextInt();
        l2 = new Node(x);
        Node temp = l2;

        while (x != -1) {
            x = sc.nextInt();
            if (x == -1)
                break;
            if (hash.containsKey(x)) {
                temp.next = hash.get(x);
                break;
            }
            Node n = new Node(x);
            temp.next = n;
            temp = n;
        }

        System.out.print("L1 - ");
        printLinkedList(l1);
        System.out.print("L2 - ");
        printLinkedList(l2);

        Solution s = new Solution();

        Node intersectionPoint = s.intersectionOfTwoLinkedLists(l1, l2);
        if (intersectionPoint != null)
            System.out.println("Intersection at node with data = " + intersectionPoint.data);
        else
            System.out.println("No intersection found.");
    }
}







Arrange Odd Even linked list




import java.util.Scanner;

class ListNode {
    int val;
    ListNode next;

    ListNode(int val) {
        this.val = val;
        this.next = null;
    }
}

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        int n = scanner.nextInt();
        ListNode head = null;
        ListNode tail = null;

        for (int i = 0; i < n; i++) {
            int val = scanner.nextInt();
            if (head == null) {
                head = new ListNode(val);
                tail = head;
            } else {
                tail.next = new ListNode(val);
                tail = tail.next;
            }
        }

        System.out.print("Original List: ");
        printList(head);

        head = groupOddEven(head);
        
        System.out.print("\nModified List: ");
        printList(head);

        scanner.close();
    }

    private static ListNode groupOddEven(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }

        ListNode oddHead = head;
        ListNode evenHead = head.next;
        ListNode oddTail = oddHead;
        ListNode evenTail = evenHead;

        while (evenTail != null && evenTail.next != null) {
            oddTail.next = evenTail.next;
            oddTail = oddTail.next;
            evenTail.next = oddTail.next;
            evenTail = evenTail.next;
        }

        oddTail.next = evenHead;

        return oddHead;
    }

    private static void printList(ListNode head) {
        while (head != null) {
            System.out.print(head.val + " ");
            head = head.next;
        }
    }
}





Reverse List


import java.util.Scanner;
import java.util.Stack;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        String input = scanner.nextLine();
        String[] items = input.split(" ");

        Stack<String> stack = new Stack<>();

        for (String item : items) {
            stack.push(item);
        }

        System.out.print("[");
        while (!stack.isEmpty()) {
            System.out.print("'" + stack.pop() + "'");
            if (!stack.isEmpty()) {
                System.out.print(", ");
            }
        }
        System.out.println("]");

        scanner.close();
    }
}


Sort linked list containing 0's, 1's, 2's.



import java.util.Scanner;

class ListNode {
    int val;
    ListNode next;

    ListNode(int val) {
        this.val = val;
        this.next = null;
    }
}

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        int N = scanner.nextInt();

        ListNode head = null;
        ListNode tail = null;

        for (int i = 0; i < N; i++) {
            int val = scanner.nextInt();
            if (head == null) {
                head = new ListNode(val);
                tail = head;
            } else {
                tail.next = new ListNode(val);
                tail = tail.next;
            }
        }

        head = sortList(head);
        printList(head);

        scanner.close();
    }

    private static ListNode sortList(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }

        ListNode zeroDummy = new ListNode(0);
        ListNode oneDummy = new ListNode(0);
        ListNode twoDummy = new ListNode(0);

        ListNode zeroTail = zeroDummy;
        ListNode oneTail = oneDummy;
        ListNode twoTail = twoDummy;

        ListNode current = head;
        while (current != null) {
            if (current.val == 0) {
                zeroTail.next = current;
                zeroTail = zeroTail.next;
            } else if (current.val == 1) {
                oneTail.next = current;
                oneTail = oneTail.next;
            } else {
                twoTail.next = current;
                twoTail = twoTail.next;
            }
            current = current.next;
        }

        zeroTail.next = (oneDummy.next != null) ? oneDummy.next : twoDummy.next;
        oneTail.next = twoDummy.next;
        twoTail.next = null;

        return zeroDummy.next;
    }

    private static void printList(ListNode head) {
        while (head != null) {
            System.out.print(head.val + " ");
            head = head.next;
        }
    }
}




Even and Odd using linked list



#include<iostream>
using namespace std;
class node{
	public:
	int data;
	node *next;
	node(int d)
	{
		data=d;
		next=NULL;
	}
};
void insertathead(node* &head,int data)
{
	node *n=new node(data);
	n->next=head;
	head=n;
}
void attail(node* &head,int data)
{
	if(head==NULL)
	{
		head=new node(data);
		return;
	}
	node *tail=head;
	while(tail->next!=NULL)
	{
		tail=tail->next;

	}
	tail->next=new node(data);
	return;

}
void buildlist(node *&head)
{
	int data;
	cin>>data;
	while(data!=-1)
	{
		attail(head,data);
		cin>>data;
	}
}

void evenodd(node *&head)
{
	node *evenstart=NULL;
	node *evenend=NULL;
	node *oddend=NULL;
	node *oddstart=NULL;
	node *curr=head;
	while(curr!=NULL)
	{
		int val=curr->data;
		if(val %2==0)
		{
			if(evenstart==NULL)
			{
				evenstart=curr;
				evenend=evenstart;
			}
			else
			{
				evenend->next=curr;
				evenend=evenend->next;
			}
		}
		else{
			if(oddstart==NULL)
			{
				oddstart=curr;
				oddend=oddstart;
			}
			else
			{
				oddend->next=curr;
				oddend=oddend->next;
			}	
		}
        curr=curr->next;
	}
	if(oddstart==NULL||evenstart==NULL)
	{   
        
		return;
	}

	
	oddend->next=evenstart;
    evenend->next=NULL;
	head=oddstart;
}


void print(node*head){
    //node*temp = head;
    
    while(head!=NULL){
        cout<<head->data<<" ";
        head = head->next;
    }
    cout<<endl;
}
int main() {
	int n,val;
	
	
	
		cin>>n;
		node *head1=NULL;
		for(int i=1;i<=n;i++)
	{
		cin>>val;
		if(i==1)
		{
			node *n2=new node(val);
			head1=n2;
		}
		else
		{
			attail(head1,val);
		}
	}
		evenodd(head1);
	    print(head1);
	return 0;
}



Middle of the LL



import java.util.Scanner;

class ListNode {
    int val;
    ListNode next;

    ListNode(int val) {
        this.val = val;
        this.next = null;
    }
}

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        int n = scanner.nextInt();

        ListNode head = null;
        ListNode tail = null;

        for (int i = 0; i < n; i++) {
            int val = scanner.nextInt();
            if (head == null) {
                head = new ListNode(val);
                tail = head;
            } else {
                tail.next = new ListNode(val);
                tail = tail.next;
            }
        }

        ListNode middle = findMiddleNode(head);
        System.out.println( middle.val);

        scanner.close();
    }

    private static ListNode findMiddleNode(ListNode head) {
        if (head == null) {
            return null;
        }

        ListNode slow = head;
        ListNode fast = head;

        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }

        return slow;
    }
}


Remove Nth Node From End of List



import java.util.Scanner;

class ListNode {
    int val;
    ListNode next;

    ListNode(int val) {
        this.val = val;
        this.next = null;
    }
}

class Main {
    static ListNode removeNthFromEnd(ListNode head, int n) {
        if (head == null) {
            return null;
        }

        ListNode dummy = new ListNode(0);
        dummy.next = head;

        ListNode first = dummy;
        ListNode second = dummy;

        // Move the second pointer to the nth node from the beginning
        for (int i = 0; i <= n; i++) {
            if (second == null) {
                return null; // Invalid input: n is greater than the number of nodes
            }
            second = second.next;
        }

        // Move both pointers simultaneously until the second pointer reaches the end
        while (second != null) {
            first = first.next;
            second = second.next;
        }

        // Remove the nth node from the end
        first.next = first.next.next;

        return dummy.next;
    }

    static void printList(ListNode head) {
        ListNode current = head;
        while (current != null) {
            System.out.print(current.val + " ");
            current = current.next;
        }
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        int n = scanner.nextInt();
        int x = scanner.nextInt();

        if (n == 0) {
            System.out.println(-1);
            return;
        }

        ListNode head = null;
        ListNode tail = null;

        for (int i = 0; i < n; i++) {
            int data = scanner.nextInt();
            ListNode newNode = new ListNode(data);
            if (head == null) {
                head = newNode;
                tail = newNode;
            } else {
                tail.next = newNode;
                tail = newNode;
            }
        }

        head = removeNthFromEnd(head, x);
        if (head != null) {
            printList(head);
        } else {
            System.out.println(-1);
        }
    }
}




Insertion Sort List



import java.util.Scanner;

class ListNode {
    int val;
    ListNode next;

    ListNode(int val) {
        this.val = val;
        this.next = null;
    }
}

class Main {
    static ListNode insertionSortList(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }

        ListNode dummy = new ListNode(0);
        dummy.next = head;

        ListNode current = head.next;
        ListNode lastSorted = head;

        while (current != null) {
            if (current.val >= lastSorted.val) {
                lastSorted = current;
                current = current.next;
            } else {
                ListNode prev = dummy;
                while (prev.next.val < current.val) {
                    prev = prev.next;
                }

                lastSorted.next = current.next;
                current.next = prev.next;
                prev.next = current;

                current = lastSorted.next;
            }
        }

        return dummy.next;
    }

    static void printList(ListNode head) {
        ListNode current = head;
        while (current != null) {
            System.out.print(current.val + " ");
            current = current.next;
        }
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        int n = scanner.nextInt();
        if (n == 0) {
            System.out.println(-1);
            return;
        }

        ListNode head = null;
        ListNode tail = null;

        for (int i = 0; i < n; i++) {
            int data = scanner.nextInt();
            ListNode newNode = new ListNode(data);
            if (head == null) {
                head = newNode;
                tail = newNode;
            } else {
                tail.next = newNode;
                tail = newNode;
            }
        }

        head = insertionSortList(head);
        printList(head);
    }
}



Kartik bhaiya with odd Even Linked List



import java.util.Scanner;

class ListNode {
    int val;
    ListNode next;

    ListNode(int val) {
        this.val = val;
        this.next = null;
    }
}

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        int n = scanner.nextInt(); // Number of nodes in the linked list

        ListNode head = null; // Head of the linked list
        ListNode tail = null; // Tail of the linked list

        // Construct the linked list
        for (int i = 0; i < n; i++) {
            int val = scanner.nextInt();
            if (head == null) {
                head = new ListNode(val);
                tail = head;
            } else {
                tail.next = new ListNode(val);
                tail = tail.next;
            }
        }

        // Reorder the linked list to group nodes with odd indices together followed by even indices
        head = reorderList(head);

        // Print the updated list
        printList(head);

        scanner.close();
    }

    // Function to reorder the linked list to group nodes with odd indices together followed by even indices
    private static ListNode reorderList(ListNode head) {
        if (head == null || head.next == null || head.next.next == null) {
            return head; // List has 0, 1, or 2 nodes, no reordering needed
        }

        ListNode oddHead = head; // Head of the list containing nodes with odd indices
        ListNode evenHead = head.next; // Head of the list containing nodes with even indices

        ListNode oddTail = oddHead; // Tail of the list containing nodes with odd indices
        ListNode evenTail = evenHead; // Tail of the list containing nodes with even indices

        ListNode current = evenHead.next; // Pointer to the next node to be processed

        boolean isOdd = true; // Indicates whether the next node should be appended to the odd list or even list

        while (current != null) {
            if (isOdd) {
                oddTail.next = current;
                oddTail = oddTail.next;
            } else {
                evenTail.next = current;
                evenTail = evenTail.next;
            }

            // Toggle the flag to switch between odd and even lists
            isOdd = !isOdd;
            current = current.next;
        }

        // Connect the tail of the odd list to the head of the even list
        oddTail.next = evenHead;
        // Set the next of evenTail to null to mark the end of the reordered list
        evenTail.next = null;

        return oddHead; // Return the head of the reordered list
    }

    // Function to print the linked list
    private static void printList(ListNode head) {
        while (head != null) {
            System.out.print(head.val + " ");
            head = head.next;
        }
    }
}



























